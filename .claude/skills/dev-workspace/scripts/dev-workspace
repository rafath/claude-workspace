#!/bin/bash

# dev-workspace ‚Äî Dev workspace git workflow management
# https://github.com/dilberryhoundog/dev-workspace

set -e

VERSION="1.0.0"
CONFIG_FILE="dev/workspace/workspace-config.yml"
CONTEXT_FILE="dev/workspace/workspace.yml"

# Resolve skill directory (where templates live)
# Follows symlinks to find the real skill root
resolve_skill_dir() {
    local script_path="${BASH_SOURCE[0]}"
    # Follow symlinks
    while [[ -L "$script_path" ]]; do
        local link_target
        link_target=$(readlink "$script_path")
        if [[ "$link_target" == /* ]]; then
            script_path="$link_target"
        else
            script_path="$(dirname "$script_path")/$link_target"
        fi
    done
    # scripts/ is one level under skill root
    local scripts_dir
    scripts_dir=$(cd "$(dirname "$script_path")" && pwd)
    echo "$(dirname "$scripts_dir")"
}

SKILL_DIR=$(resolve_skill_dir)

# ==============================================================================
# YAML PARSER
# ==============================================================================
# YAML parser supporting dotted key paths of any depth.
# Handles comments, quoted values, and arrays.
# Keys use dot notation: "init.merge_protection.directories"

# Walk a dotted key path through indented YAML, output the target block.
# Returns lines from the matched key's scope (its value + children).
_yaml_walk() {
    local file="$1"
    IFS='.' read -ra parts <<< "$2"

    local depth=0
    local target="${parts[$depth]}"
    local max_depth=$(( ${#parts[@]} - 1 ))
    local found=false
    local target_indent=-1

    while IFS= read -r line; do
        # Skip blank lines and comments
        [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && {
            [[ "$found" == true ]] && echo "$line"
            continue
        }

        # Calculate indent (number of leading spaces)
        local stripped="${line#"${line%%[![:space:]]*}"}"
        local indent=$(( ${#line} - ${#stripped} ))

        # If we've found our target and hit same/lower indent, we're done
        if [[ "$found" == true && "$indent" -le "$target_indent" ]]; then
            break
        fi

        if [[ "$found" == true ]]; then
            echo "$line"
            continue
        fi

        # Match current target at expected indent level
        local expected_indent=$(( depth * 2 ))
        if [[ "$indent" -eq "$expected_indent" || ("$indent" -ge "$expected_indent" && "$depth" -gt 0) ]]; then
            local key_part="${stripped%%:*}"
            key_part="${key_part%% *}"
            if [[ "$key_part" == "$target" ]]; then
                if [[ "$depth" -eq "$max_depth" ]]; then
                    # Found final key ‚Äî check for inline value
                    local value="${stripped#*: }"
                    if [[ "$value" != "$stripped" && "$value" != *":" ]]; then
                        # Inline value (not just "key:")
                        echo "$line"
                    fi
                    found=true
                    target_indent=$indent
                else
                    # Descend to next level
                    (( depth++ ))
                    target="${parts[$depth]}"
                fi
            fi
        fi
    done < "$file"

    [[ "$found" == true ]]
}

yaml_get() {
    local file="$1" key="$2"
    [[ ! -f "$file" ]] && return 1

    local output
    output=$(_yaml_walk "$file" "$key") || return 1

    # Extract scalar value from first line
    echo "$output" | head -1 | sed 's/^[^:]*: *//' | sed 's/ *#.*//' | sed 's/^["'\'']\(.*\)["'\'']$/\1/'
}

yaml_get_array() {
    local file="$1" key="$2"
    [[ ! -f "$file" ]] && return 1

    _yaml_walk "$file" "$key" | grep -E '^ *- ' | sed 's/^ *- *//' | sed 's/^["'\'']\(.*\)["'\'']$/\1/'
}

yaml_section_exists() {
    local file="$1" key="$2"
    [[ ! -f "$file" ]] && return 1

    _yaml_walk "$file" "$key" >/dev/null 2>&1
}

# ==============================================================================
# PROJECT ROOT DETECTION
# ==============================================================================

find_project_root() {
    local dir="${1:-$PWD}"
    while [[ "$dir" != "/" ]]; do
        if [[ -f "$dir/$CONFIG_FILE" ]]; then
            echo "$dir"
            return 0
        fi
        dir="$(dirname "$dir")"
    done
    return 1
}

# ==============================================================================
# CONFIG LOADING
# ==============================================================================

load_config() {
    PROJECT_ROOT=$(find_project_root) || {
        echo "‚ùå Not in a dev-workspace project"
        echo "   No $CONFIG_FILE found in current or parent directories"
        echo "   Run: dev-workspace init --write"
        exit 1
    }

    CONFIG="$PROJECT_ROOT/$CONFIG_FILE"

    # Repo config
    MAIN_BRANCH=$(yaml_get "$CONFIG" "repo_config.main_branch") || MAIN_BRANCH="main"
    PARENT_BRANCH=$(yaml_get "$CONFIG" "repo_config.parent_branch") || PARENT_BRANCH="main"
    ORIGIN=$(yaml_get "$CONFIG" "repo_config.origin") || ORIGIN=""
    UPSTREAM=$(yaml_get "$CONFIG" "repo_config.upstream") || UPSTREAM=""
    WORKSPACE_REMOTE=$(yaml_get "$CONFIG" "repo_config.workspace") || WORKSPACE_REMOTE=""
    UPSTREAM_LATEST_TO=$(yaml_get "$CONFIG" "repo_config.upstream_latest_to") || UPSTREAM_LATEST_TO=""

    # Merge config
    MERGE_STRATEGY=$(yaml_get "$CONFIG" "merge.strategy") || MERGE_STRATEGY="--merge"
    ARCHIVE_BEFORE_MERGE=$(yaml_get "$CONFIG" "merge.archive_before_merge") || ARCHIVE_BEFORE_MERGE=""
    DELETE_BRANCH=$(yaml_get "$CONFIG" "merge.delete_branch_after_merge") || DELETE_BRANCH=""

    # Commit config
    COMMIT_MESSAGE=$(yaml_get "$CONFIG" "commit_workspace.message") || COMMIT_MESSAGE="üìù Workspace files updated!"

    # Archive config
    ARCHIVE_DIR=$(yaml_get "$CONFIG" "archive.directory") || ARCHIVE_DIR="dev/branches"

    # Deploy config
    DEPLOY_SOURCE=$(yaml_get "$CONFIG" "deploy.deploy_source") || DEPLOY_SOURCE=""
    DEPLOY_BRANCH=$(yaml_get "$CONFIG" "deploy.deploy_branch") || DEPLOY_BRANCH=""

    # Change to project root for all git operations
    cd "$PROJECT_ROOT"

    # Resolve actual git remote names from configured URLs
    ORIGIN_REMOTE=$(resolve_remote_name "$ORIGIN")
    if is_fork; then
        UPSTREAM_REMOTE=$(resolve_remote_name "$UPSTREAM")
    else
        UPSTREAM_REMOTE=""
    fi
}

# ==============================================================================
# HELPERS
# ==============================================================================

current_branch() {
    git branch --show-current
}

is_clean() {
    [[ -z $(git status --porcelain) ]]
}

require_clean() {
    if ! is_clean; then
        echo "‚ùå Working tree is not clean"
        echo "   Commit or stash changes first"
        echo ""
        git status --short
        exit 2
    fi
}

is_fork() {
    [[ -n "$UPSTREAM" && "$UPSTREAM" != "false" ]]
}

# Resolve git remote name from a URL configured in workspace-config.yml.
# If the URL matches an existing remote, return its name.
# Falls back to "origin" if no match found.
resolve_remote_name() {
    local target_url="$1"
    [[ -z "$target_url" ]] && echo "origin" && return

    while IFS= read -r line; do
        local name="${line%%	*}"
        local url="${line#*	}"
        url="${url%% *}"
        if [[ "$url" == "$target_url" ]]; then
            echo "$name"
            return
        fi
    done < <(git remote -v 2>/dev/null | grep "(push)")

    echo "origin"
}

# ==============================================================================
# COMMANDS
# ==============================================================================

# ------------------------------------------------------------------------------
# HELP
# ------------------------------------------------------------------------------

cmd_help() {
    local topic="$1"

    case "$topic" in
        init)
            echo ""
            echo "dev-workspace init ‚Äî Scaffold and apply workspace config"
            echo ""
            echo "Usage:"
            echo "  dev-workspace init                Scaffold config files from skill template"
            echo "  dev-workspace init --write        Apply config settings to project (idempotent)"
            echo "  dev-workspace init --check        Verify settings are applied"
            echo ""
            echo "The init process has three steps:"
            echo "  1. Run 'init' to scaffold workspace-config.yml and workspace.yml"
            echo "  2. Edit workspace-config.yml for your project (fork vs vanilla, remotes)"
            echo "  3. Run 'init --write' to apply settings to git, gitattributes, etc."
            echo ""
            ;;
        new)
            echo ""
            echo "dev-workspace new ‚Äî Create or list workspace branches"
            echo ""
            echo "Usage:"
            echo "  dev-workspace new                 List branches from parent"
            echo "  dev-workspace new <name>          Create new workspace branch"
            echo "  dev-workspace new <name> --check  Validate readiness without creating"
            echo "  dev-workspace new <name> --force  Create even if local is behind remote"
            echo ""
            echo "Must be on parent branch. Branch is created with --no-track."
            echo ""
            ;;
        push)
            echo ""
            echo "dev-workspace push ‚Äî Push current branch to origin"
            echo ""
            echo "Usage:"
            echo "  dev-workspace push                Push current branch"
            echo "  dev-workspace push --check        Show push status (ahead/behind/diverged)"
            echo "  dev-workspace push --check --json Machine-readable status"
            echo "  dev-workspace push --force-w-l    Force push with lease (post-rebase)"
            echo ""
            ;;
        sync)
            echo ""
            echo "dev-workspace sync ‚Äî Sync current branch with parent"
            echo ""
            echo "Usage:"
            echo "  dev-workspace sync                Merge parent into current feature branch"
            echo "  dev-workspace sync --check        Show how far behind parent"
            echo "  dev-workspace sync --check --json Machine-readable status"
            echo "  dev-workspace sync --rebase       Rebase onto parent instead of merge"
            echo ""
            echo "Must be on a feature branch (not parent or main)."
            echo ""
            ;;
        merge)
            echo ""
            echo "dev-workspace merge ‚Äî Merge current branch to parent"
            echo ""
            echo "Usage:"
            echo "  dev-workspace merge               Auto-detect PR or local merge"
            echo "  dev-workspace merge --check       Full preflight report (ALWAYS run first)"
            echo "  dev-workspace merge --check --json Machine-readable preflight"
            echo "  dev-workspace merge --local       Force local merge (skip PR detection)"
            echo "  dev-workspace merge --github      Force GitHub PR merge"
            echo ""
            echo "Reads merge strategy from config. Workspace files are protected."
            echo ""
            ;;
        commit)
            echo ""
            echo "dev-workspace commit ‚Äî Commit workspace files only"
            echo ""
            echo "Usage:"
            echo "  dev-workspace commit              Commit configured workspace directories"
            echo "  dev-workspace commit --check      Show what would be committed"
            echo ""
            echo "Unstages everything first, then stages only workspace dirs from config."
            echo ""
            ;;
        archive)
            echo ""
            echo "dev-workspace archive ‚Äî Archive workspace context"
            echo ""
            echo "Usage:"
            echo "  dev-workspace archive             Archive workspace to dev/branches/"
            echo "  dev-workspace archive --check     Show archive status + sync divergences"
            echo "  dev-workspace archive --sync      Bidirectional sync archives with parent"
            echo "  dev-workspace archive --path      Output archive path (for scripting)"
            echo "  dev-workspace archive --no-commit Archive files but skip git commit"
            echo ""
            ;;
        latest)
            echo ""
            echo "dev-workspace latest ‚Äî Reset main branch to remote"
            echo ""
            echo "Usage:"
            echo "  dev-workspace latest --check      Show sync status with origin + upstream"
            echo "  dev-workspace latest --check --json Machine-readable status"
            echo "  dev-workspace latest --upstream   Reset local main to upstream (fork only)"
            echo "  dev-workspace latest --origin     Reset local main to origin"
            echo ""
            echo "‚ö† Destructive: unpushed commits on target branch will be lost."
            echo "Must be on the target branch (upstream_latest_to from config)."
            echo ""
            ;;
        merge-latest)
            echo ""
            echo "dev-workspace merge-latest ‚Äî Merge main into parent branch"
            echo ""
            echo "Usage:"
            echo "  dev-workspace merge-latest        Merge main_branch into parent_branch"
            echo "  dev-workspace merge-latest --check Show status, verify main is current"
            echo "  dev-workspace merge-latest --check --json Machine-readable status"
            echo "  dev-workspace merge-latest --ff   Allow fast-forward merge"
            echo ""
            echo "Only for fork repos where main ‚â† parent. Errors on vanilla repos."
            echo ""
            ;;
        rebuild)
            echo ""
            echo "dev-workspace rebuild ‚Äî Pull dev-workspace updates"
            echo ""
            echo "Usage:"
            echo "  dev-workspace rebuild             Pull from workspace remote into parent"
            echo "  dev-workspace rebuild --check     Check if updates are available"
            echo ""
            echo "Requires 'workspace' remote (set up by init --write)."
            echo ""
            ;;
        deploy)
            echo ""
            echo "dev-workspace deploy ‚Äî Deploy push workflow"
            echo ""
            echo "Usage:"
            echo "  dev-workspace deploy push         Push source to deploy target"
            echo "  dev-workspace deploy push --check Show deploy status"
            echo ""
            echo "Supports remote deploy (separate repo) and local deploy (same repo)."
            echo "Configure in workspace-config.yml under 'deploy' section."
            echo ""
            ;;
        *)
            echo ""
            echo "dev-workspace v${VERSION} ‚Äî Git workflow management"
            echo ""
            echo "Usage: dev-workspace <command> [options]"
            echo "       dev-workspace help <command>  Show command details"
            echo ""
            echo "Commands:"
            echo "  init              Scaffold and apply workspace config"
            echo "  new [name]        Create or list workspace branches"
            echo "  push              Push current branch to remote"
            echo "  sync              Sync current branch with parent"
            echo "  merge             Merge current branch to parent"
            echo "  commit            Commit workspace files only"
            echo "  archive           Archive workspace context"
            echo "  latest            Reset main to upstream/origin"
            echo "  merge-latest      Merge main into parent branch"
            echo "  rebuild           Pull dev-workspace updates"
            echo "  deploy            Deploy push workflow"
            echo "  help              Show this help"
            echo ""
            echo "Global options:"
            echo "  --check           Inspect state without changes"
            echo "  --check --json    Machine-readable check output"
            echo "  --project <path>  Override project root"
            echo ""
            ;;
    esac
}

# ------------------------------------------------------------------------------
# INIT
# ------------------------------------------------------------------------------

cmd_init() {
    local mode="$1"

    case "$mode" in
        --write)
            init_write
            ;;
        --check)
            init_check
            ;;
        *)
            init_scaffold
            ;;
    esac
}

init_scaffold() {
    # Scaffold config files into dev/workspace/ from skill templates.
    # Does NOT require load_config (config doesn't exist yet).

    # Find project root (or use CWD if no config exists yet)
    local project_root="$PWD"

    local target_dir="$project_root/dev/workspace"
    local config_target="$target_dir/workspace-config.yml"
    local context_target="$target_dir/workspace.yml"

    # Check templates exist in skill dir
    local template_dir="$SKILL_DIR/templates"
    if [[ ! -f "$template_dir/workspace-config.yml" ]]; then
        echo "‚ùå Template not found: $template_dir/workspace-config.yml"
        echo "   Skill directory: $SKILL_DIR"
        exit 1
    fi

    mkdir -p "$target_dir"

    if [[ -f "$config_target" ]]; then
        echo "‚Ñπ workspace-config.yml already exists at $config_target"
        echo "  To overwrite, delete it first and re-run init"
    else
        cp "$template_dir/workspace-config.yml" "$config_target"
        echo "‚úì Created $config_target"
    fi

    if [[ -f "$context_target" ]]; then
        echo "‚Ñπ workspace.yml already exists at $context_target"
    else
        cp "$template_dir/workspace.yml" "$context_target"
        echo "‚úì Created $context_target"
    fi

    echo ""
    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
    echo "  ‚úì Config scaffolded"
    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
    echo ""
    echo "Next steps:"
    echo "  1. Edit $config_target for your project"
    echo "     (set repo URLs, branch names, fork vs vanilla)"
    echo "  2. Run: dev-workspace init --write"
}

init_write() {
    load_config
    echo ""
    echo "üîß Applying init settings..."
    echo ""

    # Merge protection
    if yaml_section_exists "$CONFIG" "init.merge_protection"; then
        git config merge.protect.name "Protect from merging"
        git config merge.protect.driver true
        echo "‚úì Merge protection driver configured"

        touch .gitattributes
        while IFS= read -r dir; do
            local attr="$dir merge=protect"
            grep -qxF "$attr" .gitattributes || echo "$attr" >> .gitattributes
        done < <(yaml_get_array "$CONFIG" "init.merge_protection.directories")
        echo "‚úì .gitattributes merge strategies set"
    fi

    # Git ignore
    if yaml_section_exists "$CONFIG" "init.git_ignore"; then
        mkdir -p .git/info && touch .git/info/exclude
        while IFS= read -r path; do
            grep -qxF "$path" .git/info/exclude || echo "$path" >> .git/info/exclude
        done < <(yaml_get_array "$CONFIG" "init.git_ignore.directories")
        echo "‚úì Local git ignores set"
    fi

    # Docker ignore
    if yaml_section_exists "$CONFIG" "init.exclude_workspace_from_docker"; then
        if [[ -f .dockerignore ]]; then
            while IFS= read -r path; do
                grep -qxF "$path" .dockerignore || echo "$path" >> .dockerignore
            done < <(yaml_get_array "$CONFIG" "init.exclude_workspace_from_docker.directories")
            echo "‚úì .dockerignore updated"
        else
            echo "‚ö† No .dockerignore found (skipped)"
        fi
    fi

    # Workspace remote
    if yaml_section_exists "$CONFIG" "init.setup_workspace_origin"; then
        if [[ -n "$WORKSPACE_REMOTE" ]]; then
            git remote add workspace "$WORKSPACE_REMOTE" 2>/dev/null || \
                git remote set-url workspace "$WORKSPACE_REMOTE"
            echo "‚úì Workspace remote configured"

            local pull_on_init
            pull_on_init=$(yaml_get "$CONFIG" "init.setup_workspace_origin.pull_workspace_on_init")
            if [[ "$pull_on_init" == "true" ]]; then
                echo ""
                echo "üîÑ Pulling workspace..."
                cmd_rebuild
            fi
        fi
    fi

    # Make scripts executable if they exist
    if [[ -d "dev/run" ]]; then
        chmod +x dev/run/* 2>/dev/null || true
        echo "‚úì Scripts in dev/run/ made executable"
    fi

    echo ""
    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
    echo "  ‚úì Init complete"
    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
}

init_check() {
    load_config
    echo ""
    echo "üîç Checking init settings..."
    echo ""

    local warnings=0

    # Merge protection
    if yaml_section_exists "$CONFIG" "init.merge_protection"; then
        if git config --get merge.protect.driver >/dev/null 2>&1; then
            echo "‚úì Merge protection driver configured"
        else
            echo "‚ö† Merge protection driver not configured"
            ((warnings++))
        fi
    fi

    # Git ignore
    if yaml_section_exists "$CONFIG" "init.git_ignore"; then
        if [[ -f .git/info/exclude ]]; then
            echo "‚úì Local git ignores file exists"
        else
            echo "‚ö† .git/info/exclude not found"
            ((warnings++))
        fi
    fi

    # Workspace remote
    if yaml_section_exists "$CONFIG" "init.setup_workspace_origin"; then
        if git remote get-url workspace >/dev/null 2>&1; then
            echo "‚úì Workspace remote: $(git remote get-url workspace)"
        else
            echo "‚ö† Workspace remote not configured"
            ((warnings++))
        fi
    fi

    echo ""
    if [[ "$warnings" -gt 0 ]]; then
        echo "$warnings issue(s) found ‚Äî run: dev-workspace init --write"
        exit 1
    else
        echo "‚úì All init settings applied"
    fi
}

# ------------------------------------------------------------------------------
# NEW
# ------------------------------------------------------------------------------

cmd_new() {
    load_config
    local name="" check=false force=false

    for arg in "$@"; do
        case "$arg" in
            help|--help) cmd_help new; return ;;
            --check) check=true ;;
            --force) force=true ;;
            *) [[ -z "$name" ]] && name="$arg" ;;
        esac
    done

    # No name ‚Äî list branches from parent
    if [[ -z "$name" && "$check" == false ]]; then
        echo ""
        echo "Branches from $PARENT_BRANCH:"
        echo ""
        git branch --list | grep -v "^[* ]*${MAIN_BRANCH}$" | grep -v "^[* ]*${PARENT_BRANCH}$" | sed 's/^[ *]*/  /'
        echo ""
        echo "Usage: dev-workspace new <branch-name>"
        return 0
    fi

    local branch
    branch=$(current_branch)

    if [[ "$check" == true ]]; then
        echo ""
        echo "üîç New branch readiness check"
        echo ""

        local warnings=0

        # Must be on parent branch
        if [[ "$branch" == "$PARENT_BRANCH" ]]; then
            echo "‚úì On parent branch: $PARENT_BRANCH"
        else
            echo "‚ö† Not on parent branch (on: $branch, expected: $PARENT_BRANCH)"
            ((warnings++))
        fi

        # Clean working tree
        if is_clean; then
            echo "‚úì Working tree is clean"
        else
            echo "‚ö† Working tree has uncommitted changes"
            ((warnings++))
        fi

        # Sync with remote
        git fetch "$ORIGIN_REMOTE" "$PARENT_BRANCH" 2>/dev/null || true
        local behind
        behind=$(git rev-list --count HEAD.."$ORIGIN_REMOTE/$PARENT_BRANCH" 2>/dev/null || echo "0")
        local ahead
        ahead=$(git rev-list --count "$ORIGIN_REMOTE/$PARENT_BRANCH"..HEAD 2>/dev/null || echo "0")

        if [[ "$behind" -eq 0 ]]; then
            echo "‚úì In sync with origin/$PARENT_BRANCH"
        else
            echo "‚ö† Local is $behind commit(s) behind origin/$PARENT_BRANCH"
            ((warnings++))
        fi
        if [[ "$ahead" -gt 0 ]]; then
            echo "  ‚Ñπ Local has $ahead unpushed commit(s)"
        fi

        echo ""
        if [[ "$warnings" -gt 0 ]]; then
            echo "$warnings warning(s) ‚Äî review before creating branch"
            exit 1
        else
            echo "‚úì Ready to create new branch"
        fi
        return 0
    fi

    # Validate on parent branch
    if [[ "$branch" != "$PARENT_BRANCH" ]]; then
        echo "‚ùå Must be on $PARENT_BRANCH branch (currently on: $branch)"
        exit 1
    fi

    require_clean

    # Check sync status (unless --force)
    if [[ "$force" == false ]]; then
        git fetch "$ORIGIN_REMOTE" "$PARENT_BRANCH" 2>/dev/null || true
        local behind
        behind=$(git rev-list --count HEAD.."$ORIGIN_REMOTE/$PARENT_BRANCH" 2>/dev/null || echo "0")
        if [[ "$behind" -gt 0 ]]; then
            echo "‚ùå Local $PARENT_BRANCH is $behind commit(s) behind origin"
            echo "   Run: dev-workspace latest --origin"
            echo "   Or:  dev-workspace new $name --force"
            exit 3
        fi
    fi

    # Check if branch exists
    if git rev-parse --verify "$name" >/dev/null 2>&1; then
        echo "‚ùå Branch '$name' already exists"
        echo "   Switch to it: git checkout $name"
        exit 4
    fi

    # Create branch
    git checkout -b "$name" --no-track "$PARENT_BRANCH"

    echo ""
    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
    echo "  ‚úì Created branch: $name"
    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
    echo ""
    echo "Next: make commits, then dev-workspace push"
}

# ------------------------------------------------------------------------------
# PUSH
# ------------------------------------------------------------------------------

cmd_push() {
    load_config
    local check=false force_wl=false

    for arg in "$@"; do
        case "$arg" in
            help|--help) cmd_help push; return ;;
            --check) check=true ;;
            --force-w-l) force_wl=true ;;
        esac
    done

    local branch
    branch=$(current_branch)

    if [[ "$check" == true ]]; then
        echo ""
        echo "üîç Push status for $branch"
        echo ""

        git fetch "$ORIGIN_REMOTE" >/dev/null 2>&1

        local upstream="$ORIGIN_REMOTE/$branch"
        if git rev-parse --verify "$upstream" >/dev/null 2>&1; then
            local ahead behind
            ahead=$(git rev-list --count "$upstream"..HEAD)
            behind=$(git rev-list --count HEAD.."$upstream")

            if [[ "$ahead" -eq 0 && "$behind" -eq 0 ]]; then
                echo "‚úì Already up to date with origin"
            elif [[ "$behind" -gt 0 && "$ahead" -gt 0 ]]; then
                echo "‚ö† Diverged: $ahead ahead, $behind behind origin"
                echo "  Force push needed: dev-workspace push --force-w-l"
                exit 2
            elif [[ "$behind" -gt 0 ]]; then
                echo "‚ö† Behind origin by $behind commit(s)"
                echo "  Pull first or force push: dev-workspace push --force-w-l"
                exit 2
            else
                echo "‚úì $ahead commit(s) to push"
            fi
        else
            echo "‚Ñπ New branch ‚Äî will create remote tracking branch"
        fi
        return 0
    fi

    # Push
    echo ""
    echo "üîÑ Pushing $branch to origin..."

    if [[ "$force_wl" == true ]]; then
        git push --force-with-lease "$ORIGIN_REMOTE" "$branch"
    else
        git push -u "$ORIGIN_REMOTE" "$branch"
    fi

    echo ""
    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
    echo "  ‚úì Pushed to origin/$branch"
    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
}

# ------------------------------------------------------------------------------
# SYNC
# ------------------------------------------------------------------------------

cmd_sync() {
    load_config
    local check=false use_rebase=false

    for arg in "$@"; do
        case "$arg" in
            help|--help) cmd_help sync; return ;;
            --check) check=true ;;
            --rebase) use_rebase=true ;;
        esac
    done

    local branch
    branch=$(current_branch)

    # Validate not on parent/main
    if [[ "$branch" == "$MAIN_BRANCH" || "$branch" == "$PARENT_BRANCH" ]]; then
        echo "‚ùå Already on $branch ‚Äî nothing to sync"
        echo "   Sync pulls parent into a feature branch"
        exit 1
    fi

    git fetch "$ORIGIN_REMOTE" "$PARENT_BRANCH" >/dev/null 2>&1

    local behind
    behind=$(git rev-list --count HEAD.."$ORIGIN_REMOTE/$PARENT_BRANCH" 2>/dev/null || echo "0")

    if [[ "$check" == true ]]; then
        echo ""
        echo "üîç Sync status for $branch"
        echo ""
        echo "  Parent: $PARENT_BRANCH"

        if [[ "$behind" -eq 0 ]]; then
            echo "  ‚úì Already up to date with $PARENT_BRANCH"
        else
            echo "  ‚ö† $behind commit(s) behind $PARENT_BRANCH"
        fi
        [[ "$behind" -gt 0 ]] && exit 1 || return 0
    fi

    require_clean

    if [[ "$behind" -eq 0 ]]; then
        echo "‚úì Already up to date with $PARENT_BRANCH"
        return 0
    fi

    echo ""
    echo "üîÑ Syncing $branch with $PARENT_BRANCH ($behind commits)..."

    if [[ "$use_rebase" == true ]]; then
        git rebase "$ORIGIN_REMOTE/$PARENT_BRANCH"
    else
        git merge "$ORIGIN_REMOTE/$PARENT_BRANCH" --no-edit
    fi

    echo ""
    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
    echo "  ‚úì Branch synced with $PARENT_BRANCH"
    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
}

# ------------------------------------------------------------------------------
# MERGE
# ------------------------------------------------------------------------------

cmd_merge() {
    load_config
    local check=false use_local=false use_github=false

    for arg in "$@"; do
        case "$arg" in
            help|--help) cmd_help merge; return ;;
            --check) check=true ;;
            --local) use_local=true ;;
            --github) use_github=true ;;
        esac
    done

    local branch
    branch=$(current_branch)

    # Validate not on parent/main
    if [[ "$branch" == "$MAIN_BRANCH" || "$branch" == "$PARENT_BRANCH" ]]; then
        echo "‚ùå Cannot merge from $branch"
        exit 1
    fi

    if [[ "$check" == true ]]; then
        merge_check "$branch"
        return $?
    fi

    require_clean

    # Determine merge path
    local pr_number=""
    if [[ "$use_github" == true ]]; then
        pr_number=$(gh pr view --json number -q '.number' 2>/dev/null || true)
        if [[ -z "$pr_number" ]]; then
            echo "‚ùå No PR found for this branch"
            echo "   Create one: gh pr create"
            exit 4
        fi
    elif [[ "$use_local" == false ]]; then
        # Auto-detect
        pr_number=$(gh pr view --json number -q '.number' 2>/dev/null || true)
    fi

    if [[ -n "$pr_number" && "$use_local" == false ]]; then
        merge_github "$branch" "$pr_number"
    else
        merge_local "$branch"
    fi
}

merge_check() {
    local branch="$1"
    local warnings=0
    local blockers=0

    echo ""
    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
    echo "  MERGE PREFLIGHT: $branch"
    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
    echo ""
    echo "  Target:   $PARENT_BRANCH"
    echo "  Strategy: $MERGE_STRATEGY"
    echo ""

    # Clean tree
    if is_clean; then
        echo "‚úì Working tree is clean"
    else
        echo "‚ö† Working tree has uncommitted changes"
        ((warnings++))
    fi

    # Commits pushed
    git fetch "$ORIGIN_REMOTE" >/dev/null 2>&1
    local upstream="$ORIGIN_REMOTE/$branch"
    if git rev-parse --verify "$upstream" >/dev/null 2>&1; then
        local unpushed
        unpushed=$(git rev-list --count "$upstream"..HEAD 2>/dev/null || echo "0")
        if [[ "$unpushed" -eq 0 ]]; then
            echo "‚úì All commits pushed"
        else
            echo "‚ö† $unpushed unpushed commit(s)"
            ((warnings++))
        fi
    else
        echo "‚ö† Branch not pushed to origin"
        ((warnings++))
    fi

    # Merge conflicts
    git fetch "$ORIGIN_REMOTE" "$PARENT_BRANCH" >/dev/null 2>&1
    local merge_base
    merge_base=$(git merge-base HEAD "$ORIGIN_REMOTE/$PARENT_BRANCH" 2>/dev/null || true)
    if [[ -n "$merge_base" ]]; then
        local conflicts
        conflicts=$(git merge-tree "$merge_base" HEAD "$ORIGIN_REMOTE/$PARENT_BRANCH" 2>/dev/null | grep -c "^<<<<<<<" || true)
        if [[ "$conflicts" -gt 0 ]]; then
            echo "‚ùå Merge conflicts detected with $PARENT_BRANCH"
            ((blockers++))
        else
            echo "‚úì No merge conflicts"
        fi
    fi

    # PR status
    local pr_json
    pr_json=$(gh pr view --json number,state,isDraft 2>/dev/null || true)
    if [[ -n "$pr_json" ]]; then
        local pr_num
        pr_num=$(echo "$pr_json" | grep -o '"number":[0-9]*' | cut -d: -f2)
        local pr_draft
        pr_draft=$(echo "$pr_json" | grep -o '"isDraft":true' || true)
        if [[ -n "$pr_draft" ]]; then
            echo "‚ö† PR #$pr_num is in draft"
            ((warnings++))
        else
            echo "‚úì PR #$pr_num exists"
        fi
    else
        echo "‚ö† No PR for this branch"
        ((warnings++))
    fi

    # Archive check
    if [[ "$ARCHIVE_BEFORE_MERGE" == "true" ]]; then
        local archive_path
        archive_path=$(get_archive_path "$branch")
        if [[ -d "$archive_path" ]]; then
            echo "‚úì Workspace archived"
        else
            echo "‚ö† Archive required but not found"
            echo "  Run: dev-workspace archive"
            ((warnings++))
        fi
    fi

    # Summary
    echo ""
    if [[ "$blockers" -gt 0 ]]; then
        echo "‚ùå $blockers blocker(s) ‚Äî cannot merge"
        exit 2
    elif [[ "$warnings" -gt 0 ]]; then
        echo "‚ö† $warnings warning(s) ‚Äî review before merge"
        exit 1
    else
        echo "‚úì Ready to merge"
        exit 0
    fi
}

merge_local() {
    local branch="$1"

    # Push branch first
    echo ""
    echo "üîÑ Pushing $branch to origin..."
    git push -u "$ORIGIN_REMOTE" "$branch"
    echo "‚úì Pushed"

    # Checkout parent and pull
    echo ""
    echo "üîÑ Checking out $PARENT_BRANCH..."
    git checkout "$PARENT_BRANCH"
    git pull "$ORIGIN_REMOTE" "$PARENT_BRANCH"

    # Merge with workspace protection
    echo ""
    echo "üîÑ Merging $branch..."

    case "$MERGE_STRATEGY" in
        "--squash")
            git merge --squash "$branch"
            restore_workspace
            git commit -m "üîÄ merge: $branch (squash)"
            ;;
        "--rebase")
            git rebase "$branch"
            ;;
        *)
            git merge --no-ff --no-commit "$branch"
            restore_workspace
            git commit -m "üîÄ merge: $branch"
            ;;
    esac

    echo "‚úì Merged"

    # Push parent
    echo ""
    echo "üîÑ Pushing $PARENT_BRANCH..."
    git push "$ORIGIN_REMOTE" "$PARENT_BRANCH"

    # Delete branch if configured
    if [[ "$DELETE_BRANCH" == "true" ]]; then
        echo ""
        echo "üóë  Deleting branch $branch..."
        git branch -d "$branch"
        git push "$ORIGIN_REMOTE" --delete "$branch" 2>/dev/null || true
    fi

    echo ""
    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
    echo "  ‚úì Local merge complete"
    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
}

merge_github() {
    local branch="$1" pr_number="$2"

    # Push any unpushed commits
    echo ""
    echo "üîÑ Pushing to origin..."
    git push -u "$ORIGIN_REMOTE" "$branch"

    # Build gh merge flags
    local gh_flags=""
    case "$MERGE_STRATEGY" in
        "--squash") gh_flags="--squash" ;;
        "--rebase") gh_flags="--rebase" ;;
        *)          gh_flags="--merge" ;;
    esac

    echo ""
    echo "üîÑ Merging PR #$pr_number via GitHub..."
    gh pr merge "$pr_number" $gh_flags

    # Update local parent
    echo ""
    echo "üîÑ Updating local $PARENT_BRANCH..."
    git checkout "$PARENT_BRANCH"
    git pull "$ORIGIN_REMOTE" "$PARENT_BRANCH"

    if [[ "$DELETE_BRANCH" == "true" ]]; then
        git branch -d "$branch" 2>/dev/null || true
    fi

    echo ""
    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
    echo "  ‚úì GitHub merge complete (PR #$pr_number)"
    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
}

restore_workspace() {
    # After a --no-commit merge, unstage workspace files so parent's
    # version is kept and new files from feature branch are discarded.
    if git diff --cached --name-only | grep -q "^dev/workspace/"; then
        echo "üßπ Restoring workspace files..."
        git reset HEAD -- dev/workspace/ >/dev/null 2>&1 || true
        git checkout -- dev/workspace/ >/dev/null 2>&1 || true
        git clean -fd -- dev/workspace/ >/dev/null 2>&1 || true
        echo "‚úì Workspace files preserved"
    fi
}

# ------------------------------------------------------------------------------
# COMMIT
# ------------------------------------------------------------------------------

cmd_commit() {
    load_config
    local check=false

    for arg in "$@"; do
        case "$arg" in
            help|--help) cmd_help commit; return ;;
            --check) check=true ;;
        esac
    done

    local workspace_dir
    workspace_dir=$(yaml_get "$CONFIG" "commit_workspace.directories" 2>/dev/null || echo "dev/workspace")

    # Unstage everything first
    git reset HEAD -- . >/dev/null 2>&1 || true

    # Stage configured directories
    while IFS= read -r dir; do
        [[ -n "$dir" ]] && git add "$dir" 2>/dev/null || true
    done < <(yaml_get_array "$CONFIG" "commit_workspace.directories")

    if [[ "$check" == true ]]; then
        echo ""
        echo "üîç Workspace files to commit:"
        echo ""
        if git diff --cached --quiet 2>/dev/null; then
            echo "  (no changes)"
        else
            git diff --cached --name-only | sed 's/^/  /'
        fi
        # Unstage since we were just checking
        git reset HEAD -- . >/dev/null 2>&1 || true
        return 0
    fi

    if git diff --cached --quiet 2>/dev/null; then
        echo "‚Ñπ No workspace changes to commit"
        return 0
    fi

    echo ""
    echo "üìù Committing workspace files..."
    git diff --cached --name-only | sed 's/^/  /'
    echo ""
    git commit -m "$COMMIT_MESSAGE"

    echo ""
    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
    echo "  ‚úì Workspace committed"
    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
}

# ------------------------------------------------------------------------------
# ARCHIVE
# ------------------------------------------------------------------------------

get_archive_path() {
    local branch="${1:-$(current_branch)}"
    local archive_name

    if [[ "$branch" =~ ^(([^/]+)/)?(.+)$ ]]; then
        local branch_type="${BASH_REMATCH[2]}"
        local branch_desc="${BASH_REMATCH[3]}"

        if [[ -n "$branch_type" ]]; then
            archive_name="${branch_type}_${branch_desc}"
        else
            archive_name="${branch_desc}"
        fi
    else
        archive_name="$branch"
    fi

    echo "$ARCHIVE_DIR/$archive_name"
}

cmd_archive() {
    load_config
    local check=false sync=false show_path=false no_commit=false

    for arg in "$@"; do
        case "$arg" in
            help|--help) cmd_help archive; return ;;
            --check) check=true ;;
            --sync) sync=true ;;
            --path) show_path=true ;;
            --no-commit) no_commit=true ;;
        esac
    done

    local branch
    branch=$(current_branch)
    local archive_path
    archive_path=$(get_archive_path "$branch")

    if [[ "$show_path" == true ]]; then
        echo "$archive_path"
        return 0
    fi

    if [[ "$sync" == true ]]; then
        archive_sync "$branch"
        return $?
    fi

    if [[ "$check" == true ]]; then
        echo ""
        echo "üîç Archive status for $branch"
        echo ""
        echo "  Path: $archive_path"

        if [[ -d "$archive_path" ]]; then
            local last_modified
            # macOS stat
            last_modified=$(stat -f "%Sm" -t "%Y-%m-%d %H:%M" "$archive_path" 2>/dev/null || \
                           stat -c "%y" "$archive_path" 2>/dev/null | cut -d. -f1 || echo "unknown")
            echo "  ‚úì Archive exists (last updated: $last_modified)"
        else
            echo "  ‚ö† No archive found"
        fi

        # Check divergences with parent for --sync info
        archive_sync_check "$branch"
        return 0
    fi

    # Validate workspace exists
    if [[ ! -d "dev/workspace" ]]; then
        echo "‚ùå No workspace found at dev/workspace"
        exit 1
    fi

    # Archive
    mkdir -p "$archive_path"
    rsync -av --delete "dev/workspace/" "$archive_path/"

    echo ""
    echo "‚úì Archived to $archive_path"

    if [[ "$no_commit" == false ]]; then
        # Commit archive
        git reset HEAD -- . >/dev/null 2>&1 || true
        git add "$archive_path"

        if ! git diff --cached --quiet; then
            local commit_desc="${branch//\//_}"
            git commit -m "üì¶ archive workspace: $branch"
            echo "‚úì Archive committed"
        else
            echo "‚Ñπ Archive already up to date"
        fi
    fi

    echo ""
    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
    echo "  ‚úì Archive complete"
    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
}

archive_sync_check() {
    local branch="$1"

    # Determine source branch for sync
    local source_branch="$PARENT_BRANCH"

    # Archives in source
    local source_archives=()
    while IFS= read -r archive; do
        [[ -n "$archive" ]] && source_archives+=("$(basename "$archive")")
    done < <(git ls-tree -d --name-only "$source_branch" -- "$ARCHIVE_DIR" 2>/dev/null || true)

    # Archives in current
    local current_archives=()
    if [[ -d "$ARCHIVE_DIR" ]]; then
        while IFS= read -r archive; do
            [[ -n "$archive" ]] && current_archives+=("$(basename "$archive")")
        done < <(find "$ARCHIVE_DIR" -maxdepth 1 -mindepth 1 -type d 2>/dev/null || true)
    fi

    # Find differences
    local to_pull=0 to_push=0
    for archive in "${source_archives[@]}"; do
        local found=false
        for current in "${current_archives[@]}"; do
            [[ "$archive" == "$current" ]] && found=true && break
        done
        [[ "$found" == false ]] && ((to_pull++))
    done

    for archive in "${current_archives[@]}"; do
        local found=false
        for source in "${source_archives[@]}"; do
            [[ "$archive" == "$source" ]] && found=true && break
        done
        [[ "$found" == false ]] && ((to_push++))
    done

    echo ""
    echo "  Sync status with $source_branch:"
    echo "    Archives in $source_branch: ${#source_archives[@]}"
    echo "    Archives in $branch: ${#current_archives[@]}"
    if [[ "$to_pull" -gt 0 ]]; then
        echo "    ‚ö† $to_pull archive(s) to pull from $source_branch"
    fi
    if [[ "$to_push" -gt 0 ]]; then
        echo "    ‚ö† $to_push archive(s) to push to $source_branch"
    fi
    if [[ "$to_pull" -eq 0 && "$to_push" -eq 0 ]]; then
        echo "    ‚úì Archives in sync"
    fi
}

archive_sync() {
    local branch="$1"
    local source_branch="$PARENT_BRANCH"

    require_clean

    echo ""
    echo "üîÑ Syncing archives between $branch and $source_branch"
    echo ""

    # Pull first ‚Äî get archives from parent
    local source_archives=()
    while IFS= read -r archive; do
        [[ -n "$archive" ]] && source_archives+=("$(basename "$archive")")
    done < <(git ls-tree -d --name-only "$source_branch" -- "$ARCHIVE_DIR" 2>/dev/null || true)

    local current_archives=()
    if [[ -d "$ARCHIVE_DIR" ]]; then
        while IFS= read -r archive; do
            [[ -n "$archive" ]] && current_archives+=("$(basename "$archive")")
        done < <(find "$ARCHIVE_DIR" -maxdepth 1 -mindepth 1 -type d 2>/dev/null || true)
    fi

    # Pull: archives in source but not current
    local pulled=0
    for archive in "${source_archives[@]}"; do
        local found=false
        for current in "${current_archives[@]}"; do
            [[ "$archive" == "$current" ]] && found=true && break
        done
        if [[ "$found" == false ]]; then
            echo "üì• Pulling $archive from $source_branch..."
            git checkout "$source_branch" -- "$ARCHIVE_DIR/$archive"
            ((pulled++))
        fi
    done

    if [[ "$pulled" -gt 0 ]]; then
        git reset HEAD -- . >/dev/null 2>&1 || true
        git add "$ARCHIVE_DIR"
        if ! git diff --cached --quiet; then
            git commit -m "üì• pull archives from $source_branch"
            echo "‚úì Pulled $pulled archive(s)"
        fi
    fi

    # Push: archives in current but not source
    # Re-scan current archives after pull
    current_archives=()
    if [[ -d "$ARCHIVE_DIR" ]]; then
        while IFS= read -r archive; do
            [[ -n "$archive" ]] && current_archives+=("$(basename "$archive")")
        done < <(find "$ARCHIVE_DIR" -maxdepth 1 -mindepth 1 -type d 2>/dev/null || true)
    fi

    local to_push=()
    for archive in "${current_archives[@]}"; do
        local found=false
        for source in "${source_archives[@]}"; do
            [[ "$archive" == "$source" ]] && found=true && break
        done
        [[ "$found" == false ]] && to_push+=("$archive")
    done

    if [[ ${#to_push[@]} -gt 0 ]]; then
        echo ""
        echo "üì§ Pushing ${#to_push[@]} archive(s) to $source_branch..."

        git checkout "$source_branch"

        for archive in "${to_push[@]}"; do
            git checkout "$branch" -- "$ARCHIVE_DIR/$archive"
        done

        git reset HEAD -- . >/dev/null 2>&1 || true
        git add "$ARCHIVE_DIR"
        if ! git diff --cached --quiet; then
            git commit -m "üì§ push archives from $branch"
            echo "‚úì Pushed ${#to_push[@]} archive(s)"
        fi

        git checkout "$branch"
    fi

    echo ""
    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
    echo "  ‚úì Archive sync complete"
    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
}

# ------------------------------------------------------------------------------
# LATEST
# ------------------------------------------------------------------------------

cmd_latest() {
    load_config
    local check=false use_upstream=false use_origin=false

    for arg in "$@"; do
        case "$arg" in
            help|--help) cmd_help latest; return ;;
            --check) check=true ;;
            --upstream) use_upstream=true ;;
            --origin) use_origin=true ;;
        esac
    done

    local target_branch="${UPSTREAM_LATEST_TO:-$MAIN_BRANCH}"

    if [[ "$check" == true ]]; then
        echo ""
        echo "üîç Latest status for $target_branch"
        echo ""

        git fetch "$ORIGIN_REMOTE" >/dev/null 2>&1

        local behind_origin ahead_origin
        behind_origin=$(git rev-list --count "$target_branch".."$ORIGIN_REMOTE/$target_branch" 2>/dev/null || echo "?")
        ahead_origin=$(git rev-list --count "$ORIGIN_REMOTE/$target_branch".."$target_branch" 2>/dev/null || echo "?")

        echo "  origin/$target_branch:"
        if [[ "$behind_origin" == "0" && "$ahead_origin" == "0" ]]; then
            echo "    ‚úì In sync"
        else
            [[ "$behind_origin" != "0" ]] && echo "    ‚ö† Local is $behind_origin behind origin"
            [[ "$ahead_origin" != "0" ]] && echo "    ‚ö† Local is $ahead_origin ahead of origin"
        fi

        if is_fork; then
            git fetch "$UPSTREAM_REMOTE" >/dev/null 2>&1 || true
            if git rev-parse --verify "$UPSTREAM_REMOTE/$target_branch" >/dev/null 2>&1; then
                local behind_upstream
                behind_upstream=$(git rev-list --count "$target_branch".."$UPSTREAM_REMOTE/$target_branch" 2>/dev/null || echo "?")
                echo ""
                echo "  $UPSTREAM_REMOTE/$target_branch:"
                if [[ "$behind_upstream" == "0" ]]; then
                    echo "    ‚úì In sync"
                else
                    echo "    ‚ö† Local is $behind_upstream behind upstream"
                fi
            fi
        fi
        return 0
    fi

    # Validate flags
    if [[ "$use_upstream" == false && "$use_origin" == false ]]; then
        echo "Usage: dev-workspace latest [--upstream|--origin|--check]"
        echo ""
        echo "  --check      Show sync status"
        echo "  --upstream   Reset local $target_branch to upstream"
        echo "  --origin     Reset local $target_branch to origin"
        return 1
    fi

    if [[ "$use_upstream" == true ]]; then
        if ! is_fork; then
            echo "‚ùå Not a fork repo ‚Äî --upstream not available"
            echo "   Use --origin instead"
            exit 1
        fi
        if [[ -z "$UPSTREAM_LATEST_TO" || "$UPSTREAM_LATEST_TO" == "false" ]]; then
            echo "‚ùå upstream_latest_to is disabled in config"
            exit 1
        fi
    fi

    # Must be on target branch
    local branch
    branch=$(current_branch)
    if [[ "$branch" != "$target_branch" ]]; then
        echo "‚ùå Must be on $target_branch (currently on: $branch)"
        exit 1
    fi

    require_clean

    local remote_ref=""
    if [[ "$use_upstream" == true ]]; then
        echo "üîÑ Fetching upstream..."
        git fetch "$UPSTREAM_REMOTE"
        remote_ref="$UPSTREAM_REMOTE/$target_branch"
    else
        echo "üîÑ Fetching origin..."
        git fetch "$ORIGIN_REMOTE"
        remote_ref="$ORIGIN_REMOTE/$target_branch"
    fi

    # Check for unpushed commits
    local ahead
    ahead=$(git rev-list --count "$remote_ref"..HEAD 2>/dev/null || echo "0")
    if [[ "$ahead" -gt 0 ]]; then
        echo ""
        echo "‚ö† Local $target_branch has $ahead commit(s) not in $remote_ref"
        echo "  These will be LOST by reset."
        echo ""
        echo "  Unpushed commits:"
        git log --oneline "$remote_ref"..HEAD | sed 's/^/    /'
        exit 3
    fi

    # Reset
    echo ""
    echo "üîÑ Resetting $target_branch to $remote_ref..."
    git reset --hard "$remote_ref"

    echo ""
    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
    echo "  ‚úì $target_branch reset to $remote_ref"
    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
    echo ""
    git log -1 --oneline
}

# ------------------------------------------------------------------------------
# MERGE-LATEST
# ------------------------------------------------------------------------------

cmd_merge_latest() {
    load_config
    local check=false use_ff=false

    for arg in "$@"; do
        case "$arg" in
            help|--help) cmd_help merge; return ;;
            help|--help) cmd_help merge-latest; return ;;
            --check) check=true ;;
            --ff) use_ff=true ;;
        esac
    done

    # Guard: cannot merge to itself
    if [[ "$MAIN_BRANCH" == "$PARENT_BRANCH" ]]; then
        echo "‚ùå main_branch and parent_branch are the same ($MAIN_BRANCH)"
        echo "   merge-latest merges main into parent (for fork repos with a command branch)"
        exit 1
    fi

    local branch
    branch=$(current_branch)

    if [[ "$branch" != "$PARENT_BRANCH" ]]; then
        echo "‚ùå Must be on $PARENT_BRANCH (currently on: $branch)"
        exit 1
    fi

    git fetch "$ORIGIN_REMOTE" "$MAIN_BRANCH" >/dev/null 2>&1

    # Verify main is pristine (matches origin)
    local local_main remote_main
    local_main=$(git rev-parse "$MAIN_BRANCH" 2>/dev/null || echo "")
    remote_main=$(git rev-parse "$ORIGIN_REMOTE/$MAIN_BRANCH" 2>/dev/null || echo "")

    if [[ "$check" == true ]]; then
        echo ""
        echo "üîç Merge-latest status"
        echo ""
        echo "  Source: $MAIN_BRANCH"
        echo "  Target: $PARENT_BRANCH"
        echo ""

        if [[ "$local_main" != "$remote_main" ]]; then
            echo "‚ö† Local $MAIN_BRANCH is not in sync with origin"
            echo "  Run: dev-workspace latest --origin (or --upstream)"
            exit 1
        else
            echo "‚úì $MAIN_BRANCH is in sync with origin"
        fi

        local behind
        behind=$(git rev-list --count HEAD.."$MAIN_BRANCH" 2>/dev/null || echo "0")
        if [[ "$behind" -eq 0 ]]; then
            echo "‚úì Already up to date"
        else
            echo "‚Ñπ $behind commit(s) to merge from $MAIN_BRANCH"
            echo ""
            echo "  Recent commits:"
            git log --oneline HEAD.."$MAIN_BRANCH" | head -5 | sed 's/^/    /'
            local total
            total=$(git rev-list --count HEAD.."$MAIN_BRANCH")
            [[ "$total" -gt 5 ]] && echo "    ... and $((total - 5)) more"
        fi
        return 0
    fi

    require_clean

    # Verify main is pristine
    if [[ "$local_main" != "$remote_main" ]]; then
        echo "‚ùå Local $MAIN_BRANCH is not in sync with origin"
        echo "   Run: dev-workspace latest --origin (or --upstream)"
        exit 3
    fi

    local behind
    behind=$(git rev-list --count HEAD.."$MAIN_BRANCH")
    if [[ "$behind" -eq 0 ]]; then
        echo "‚úì Already up to date with $MAIN_BRANCH"
        return 0
    fi

    echo ""
    echo "üîÑ Merging $MAIN_BRANCH into $PARENT_BRANCH ($behind commits)..."

    if [[ "$use_ff" == true ]]; then
        git merge "$MAIN_BRANCH" -m "üîÄ sync: merge $MAIN_BRANCH into $PARENT_BRANCH"
    else
        git merge "$MAIN_BRANCH" --no-ff -m "üîÄ sync: merge $MAIN_BRANCH into $PARENT_BRANCH"
    fi

    echo ""
    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
    echo "  ‚úì $PARENT_BRANCH synced with $MAIN_BRANCH"
    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
}

# ------------------------------------------------------------------------------
# REBUILD
# ------------------------------------------------------------------------------

cmd_rebuild() {
    load_config
    local check=false

    for arg in "$@"; do
        case "$arg" in
            help|--help) cmd_help rebuild; return ;;
            --check) check=true ;;
        esac
    done

    # Verify workspace remote
    if ! git remote get-url workspace >/dev/null 2>&1; then
        echo "‚ùå Workspace remote not configured"
        echo "   Run: dev-workspace init --write"
        exit 1
    fi

    if [[ "$check" == true ]]; then
        echo ""
        echo "üîç Checking for workspace updates..."
        git fetch workspace >/dev/null 2>&1
        local behind
        behind=$(git rev-list --count HEAD.."workspace/main" -- dev/ 2>/dev/null || echo "?")
        echo "  Workspace remote: $(git remote get-url workspace)"
        if [[ "$behind" == "0" ]]; then
            echo "  ‚úì Up to date"
        else
            echo "  ‚Ñπ Updates available"
        fi
        return 0
    fi

    local branch
    branch=$(current_branch)

    require_clean

    echo ""
    echo "üîÑ Fetching workspace remote..."
    git fetch workspace

    echo "üîÑ Checking out $PARENT_BRANCH..."
    git checkout "$PARENT_BRANCH"

    echo "üîÑ Pulling workspace updates..."
    git pull workspace main --no-edit --allow-unrelated-histories

    echo "‚úì Workspace updated on $PARENT_BRANCH"

    if [[ "$branch" != "$PARENT_BRANCH" ]]; then
        echo ""
        echo "üîÑ Returning to $branch..."
        git checkout "$branch"
        echo ""
        echo "‚Ñπ To get updates in your branch: dev-workspace sync"
    fi

    echo ""
    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
    echo "  ‚úì Workspace rebuilt"
    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
}

# ------------------------------------------------------------------------------
# DEPLOY
# ------------------------------------------------------------------------------

cmd_deploy() {
    local subcmd="$1"

    # Help before load_config so it works even without deploy configured
    case "$subcmd" in
        help|--help|"")
            cmd_help deploy; return
            ;;
    esac

    load_config
    shift 2>/dev/null || true

    if [[ -z "$DEPLOY_SOURCE" ]]; then
        echo "‚ùå Deploy not configured"
        echo "   Add deploy section to workspace-config.yml"
        exit 1
    fi

    case "$subcmd" in
        push)
            deploy_push "$@"
            ;;
        *)
            echo "Usage: dev-workspace deploy push [--check]"
            ;;
    esac
}

deploy_push() {
    local check=false

    for arg in "$@"; do
        case "$arg" in
            --check) check=true ;;
        esac
    done

    local deploy_remote_url
    deploy_remote_url=$(yaml_get "$CONFIG" "deploy.remote.deploy_remote_url")
    local deploy_remote_branch
    deploy_remote_branch=$(yaml_get "$CONFIG" "deploy.remote.deploy_remote_branch")

    if [[ "$check" == true ]]; then
        echo ""
        echo "üîç Deploy status"
        echo ""
        echo "  Source: $DEPLOY_SOURCE"
        echo "  Target: $DEPLOY_BRANCH"

        if [[ -n "$deploy_remote_url" ]]; then
            echo "  Remote: $deploy_remote_url ($deploy_remote_branch)"
        else
            echo "  Mode:   Local (same repo)"
        fi

        # Check source branch exists
        if git rev-parse --verify "$DEPLOY_SOURCE" >/dev/null 2>&1; then
            echo "  ‚úì Source branch exists"
        else
            echo "  ‚ùå Source branch '$DEPLOY_SOURCE' not found"
        fi
        return 0
    fi

    require_clean

    if [[ -n "$deploy_remote_url" ]]; then
        # Remote deploy ‚Äî push source to deploy remote
        local remote_name="deploy"
        git remote add "$remote_name" "$deploy_remote_url" 2>/dev/null || \
            git remote set-url "$remote_name" "$deploy_remote_url"

        echo ""
        echo "üîÑ Pushing $DEPLOY_SOURCE to $remote_name/$deploy_remote_branch..."
        git push "$remote_name" "$DEPLOY_SOURCE:$deploy_remote_branch"
    else
        # Local deploy ‚Äî merge source into deploy branch
        local branch
        branch=$(current_branch)

        echo ""
        echo "üîÑ Checking out $DEPLOY_BRANCH..."
        git checkout "$DEPLOY_BRANCH" 2>/dev/null || git checkout -b "$DEPLOY_BRANCH"

        echo "üîÑ Merging $DEPLOY_SOURCE..."
        git merge "$DEPLOY_SOURCE" --no-ff -m "üöÄ deploy: merge $DEPLOY_SOURCE"

        echo "üîÑ Pushing $DEPLOY_BRANCH..."
        git push "$ORIGIN_REMOTE" "$DEPLOY_BRANCH"

        git checkout "$branch"
    fi

    echo ""
    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
    echo "  ‚úì Deploy push complete"
    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
}

# ==============================================================================
# MAIN ROUTER
# ==============================================================================

# Handle --project flag
if [[ "$1" == "--project" ]]; then
    cd "$2" || { echo "‚ùå Cannot access: $2"; exit 1; }
    shift 2
fi

COMMAND="${1:-help}"
shift 2>/dev/null || true

case "$COMMAND" in
    help|--help|-h)
        cmd_help "$@"
        ;;
    init)
        cmd_init "$@"
        ;;
    new)
        cmd_new "$@"
        ;;
    push)
        cmd_push "$@"
        ;;
    sync)
        cmd_sync "$@"
        ;;
    merge)
        cmd_merge "$@"
        ;;
    merge-latest)
        cmd_merge_latest "$@"
        ;;
    commit)
        cmd_commit "$@"
        ;;
    archive)
        cmd_archive "$@"
        ;;
    latest)
        cmd_latest "$@"
        ;;
    rebuild)
        cmd_rebuild "$@"
        ;;
    deploy)
        cmd_deploy "$@"
        ;;
    version|--version|-v)
        echo "dev-workspace v${VERSION}"
        ;;
    *)
        echo "‚ùå Unknown command: $COMMAND"
        echo "   Run: dev-workspace help"
        exit 1
        ;;
esac
