#!/usr/bin/env ruby

require 'claude_hooks'
require 'json'
require 'erb'
require 'ostruct'
require 'pathname'
require 'date'
require 'fileutils'

class ExtractTranscript < ClaudeHooks::SessionEnd
  # Export directory for saved transcripts
  EXPORT_DIR = 'dev/workspace/history'
  TEMPLATES_DIR = File.expand_path('extract_transcript', __dir__)

  def call
    log "Session ended with reason: #{reason}"

    case reason
    when 'clear', 'logout', 'prompt_input_exit'
      log "Extracting transcript for session #{session_id}"
      extract_and_parse_transcript
    else
      log "Skipping transcript extraction for reason: #{reason}"
    end

    output
  end

private

  def deep_ostruct(obj)
    case obj
    when Hash
      OpenStruct.new(obj.transform_values { |v| deep_ostruct(v) })
    when Array
      obj.map { |v| deep_ostruct(v) }
    else
      obj
    end
  end

  def extract_and_parse_transcript
    return unless File.exist?(transcript_path)

    lines = read_jsonl_transcript

    # Skip headless/sidechain sessions
    if skip_session?(lines)
      log "Skipping session - Headless mode or Subagent detected"
      return
    end

    metadata = extract_metadata(lines)
    output_file = create_output_file(metadata)

    write_header(output_file, metadata)
    parse_conversation(output_file, lines)

    log "Transcript saved to: #{output_file}"

    # Auto-rename with headless Claude
    rename_transcript(output_file)
  rescue StandardError => e
    log "Failed to extract transcript: #{e.message}", level: :error
    log e.backtrace.join("\n"), level: :error
  end

  def read_jsonl_transcript
    File.readlines(transcript_path).map do |line|
      JSON.parse(line.strip, symbolize_names: true) if line.strip.length > 0
    end.compact
  end

  def skip_session?(lines)
    lines.any? do |line|
      case line
      in { type: 'queue-operation' }
        true
      in { isSidechain: true }
        true
      else
        false
      end
    end
  end

  def extract_metadata(lines)
    # Find first user message for metadata
    first_user = lines.find { |line| line[:type] == 'user' } || {}

    {
      session_id: first_user[:sessionId] || session_id,
      timestamp: format_timestamp(first_user[:timestamp]),
      git_branch: first_user[:gitBranch] || 'unknown',
      cwd: first_user[:cwd] || cwd
    }
  end

  def format_timestamp(ts)
    return 'unknown' unless ts

    dt = DateTime.parse(ts)
    dt.strftime('%Y-%m-%d %H:%M')
  rescue
    'unknown'
  end

  def create_output_file(metadata)
    export_dir = File.join(cwd, EXPORT_DIR)
    FileUtils.mkdir_p(export_dir)

    # Check if session already exists (resumed conversation)
    existing = find_existing_session_file(export_dir, metadata[:session_id])

    if existing
      log "Updating existing transcript: #{existing}"
      existing
    else
      file = File.join(export_dir, "#{metadata[:session_id]}.txt")
      log "Creating new transcript: #{file}"
      file
    end
  end

  def find_existing_session_file(dir, sess_id)
    Dir.glob(File.join(dir, '*.txt')).find do |file|
      first_line = File.open(file, &:readline).strip rescue nil
      first_line == "Session: #{sess_id}"
    end
  end

  def write_header(output_file, metadata)
    File.open(output_file, 'w') do |f|
      f.write render_template('header.txt', metadata)
    end
  end

  def parse_conversation(output_file, lines)
    File.open(output_file, 'a') do |f|
      lines.each do |line|
        output = format_line(line)
        f.write(output) if output
      end
    end
  end

  def format_line(line)
    template = case line
      # Skip metadata types
    in { type: 'file-history-snapshot' | 'queue-operation' | 'summary' }
      log "Skipping metadata: CASE SUCCESS"
      nil

      # User message - array content (filter tool_results in template)
    in { type: 'user', message: { content: [{ type: 'tool_result' }] } }
      log "User tool result blocked: CASE SUCCESS"
      nil # 'user_array.txt'

      # User message - slash command
    in { type: 'user', message: { content: msg } } if msg.include?('<command-name>')
      log "User slash command: CASE SUCCESS"
      'user_message_slash_command.txt'

      # Ignore system generated user messages.
    in { type: 'user', message: { content: msg } } if msg.include?('<local-command-stdout>') || msg.include?('Caveat: The messages below were generated by the user while running local commands.')
      log "User system message blocked: CASE SUCCESS"
      nil

      # User message - string content
    in { type: 'user', message: { content: String } }
      log "User message: CASE SUCCESS"
      'user_message.txt'

      # Assistant - has text content
    in { type: 'assistant', message: { content: [{ text: String }] } }
      log "Assistant message: CASE SUCCESS"
      'assistant_message.txt'

    in { type: 'assistant', message: { content: [{ name: 'Bash' }] } }
      log "Assistant Bash tool: CASE SUCCESS"
      'assistant_tool_bash.txt'

    in { type: 'assistant', message: { content: [{ name: name }] } } if name == 'Write' || name == 'Read' || name == 'Edit'
      log "Assistant read / write tool: CASE SUCCESS"
      'assistant_tool_read&write.txt'

    else
      log "Line not valid: CASE FAILURE"
      nil
    end

    return nil unless template

    result = render_template(template, line)
    log "Template Render: SUCCESS"
    result
  end

  def render_template(template_name, data)
    template_path = File.join(TEMPLATES_DIR, template_name)
    template_content = File.read(template_path)
    context = deep_ostruct(data)
    ERB.new(template_content, trim_mode: '-').result(context.instance_eval { binding })
  end

  def rename_transcript(output_file)
    log "Renaming transcript with headless Claude..."

    bash_cmd = %(claude -p "Read #{output_file}, analyze the conversation, edit the SUMMARY section with a descriptive summary of the conversation (max 5 lines, between `>>>` `<<<`), create a concise descriptive title (max 6 words, kebab-case), then rename the file to <yy-mm-dd>_<title>.txt" --allowedTools "Read,Edit,Bash" --model haiku)

    # # Option A: spawn + detach - Non-blocking, instant return, runs in background
    # pid = spawn(bash_cmd, out: File::NULL, err: File::NULL)
    # Process.detach(pid)
    # log "Rename spawned in background (PID: #{pid})"

    # Option B: system - Blocking, no output capture
    result = system(bash_cmd, out: File::NULL, err: File::NULL)
    log "Rename result: #{result}"
  rescue StandardError => e
    log "Rename failed: #{e.message}", level: :warn
  end
end

# CLI testing
if __FILE__ == $0
  ClaudeHooks::CLI.test_runner(ExtractTranscript)
end
