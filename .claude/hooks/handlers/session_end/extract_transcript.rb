#!/usr/bin/env ruby

require 'claude_hooks'
require 'json'
require 'erb'
require 'ostruct'
require 'pathname'
require 'date'
require 'fileutils'

class ExtractTranscript < ClaudeHooks::SessionEnd
  # Export directory for saved transcripts
  EXPORT_DIR = 'dev/workspace/history'
  TEMPLATES_DIR = File.expand_path('extract_transcript', __dir__)

  def call
    log "Session ended with reason: #{reason}"

    case reason
    when 'clear', 'logout', 'prompt_input_exit'
      log "Extracting transcript for session #{session_id}"
      # system_message!("\n--- \"Extracting Conversation, Please Wait\" ---")
      extract_and_parse_transcript
    else
      log "Skipping transcript extraction for reason: #{reason}"
    end

    output
  end

private

  def deep_ostruct(obj)
    case obj
    when Hash
      OpenStruct.new(obj.transform_values { |v| deep_ostruct(v) })
    when Array
      obj.map { |v| deep_ostruct(v) }
    else
      obj
    end
  end

  def extract_and_parse_transcript
    return unless File.exist?(transcript_path)

    lines = read_jsonl_transcript

    # Skip headless/sidechain sessions
    if skip_session?(lines)
      log 'Skipping session - Headless mode or Subagent detected'
      return
    end

    metadata = extract_metadata(lines)
    output_file = create_output_file(metadata)

    write_header(output_file, metadata)
    parse_conversation(output_file, lines)

    log "Transcript saved to: #{output_file}"

    # Auto-rename with headless Claude
    rename_transcript(output_file)
  rescue StandardError => e
    log "Failed to extract transcript: #{e.message}", level: :error
    log e.backtrace.join("\n"), level: :error
  end

  def read_jsonl_transcript
    File.readlines(transcript_path).map do |line|
      JSON.parse(line.strip, symbolize_names: true) if line.strip.length > 0
    end.compact
  end

  def skip_session?(lines)
    lines.any? do |line|
      case line
      in { type: 'queue-operation', operation: 'dequeue' }
        true
      in { isSidechain: true }
        true
      else
        false
      end
    end
  end

  def extract_metadata(lines)
    # Find first user message for metadata
    first_user = lines.find { |line| line[:type] == 'user' } || {}

    {
      session_id: first_user[:sessionId] || session_id,
      timestamp: format_timestamp(first_user[:timestamp]),
      git_branch: first_user[:gitBranch] || 'unknown',
      cwd: first_user[:cwd] || cwd
    }
  end

  def format_timestamp(ts)
    return 'unknown' unless ts

    dt = DateTime.parse(ts)
    dt.strftime('%Y-%m-%d %H:%M')
  rescue
    'unknown'
  end

  def create_output_file(metadata)
    export_dir = File.join(cwd, EXPORT_DIR)
    FileUtils.mkdir_p(export_dir)

    # Check if session already exists (resumed conversation)
    existing = find_existing_session_file(export_dir, metadata[:session_id])

    if existing
      log "Updating existing transcript: #{existing}"
      existing
    else
      file = File.join(export_dir, "#{metadata[:session_id]}.txt")
      log "Creating new transcript: #{file}"
      file
    end
  end

  def find_existing_session_file(dir, sess_id)
    Dir.glob(File.join(dir, '*.txt')).find do |file|
      first_line = File.open(file, &:readline).strip rescue nil
      first_line == "Session: #{sess_id}"
    end
  end

  def write_header(output_file, metadata)
    File.open(output_file, 'w') do |f|
      f.write render_template('header.txt', metadata)
    end
  end

  def parse_conversation(output_file, lines)
    File.open(output_file, 'a') do |f|
      lines.each do |line|
        output = format_line(line)
        f.write(output) if output
      end
    end
  end

  def format_line(line)
    template = case line
      # Skip metadata types
    in { type: 'file-history-snapshot' | 'queue-operation' | 'summary' }
      log 'Skipping metadata: CASE SUCCESS'
      nil

      # User Agent - Agent result from Task
    in { type: 'user', toolUseResult: { agentId: String, status: 'completed' } }
      log 'Task tool result: CASE SUCCESS'
      'user_agent_result.txt'

      # User Agent - Agent result from Background Task
    in { type: 'user', toolUseResult: { retrieval_status: 'success' } }
      log 'Task tool background result: CASE SUCCESS'
      'user_agent_background_result.txt'

      # User message - array content (filter tool_results in template)
    in { type: 'user', message: { content: [{ type: 'tool_result' }] } }
      log 'User tool result blocked: CASE SUCCESS'
      nil

      # User message - slash command
    in { type: 'user', message: { content: msg } } if msg.include?('<command-name>')
      log 'User slash command: CASE SUCCESS'
      'user_message_slash_command.txt'

      # Ignore system generated user messages.
    in { type: 'user', message: { content: msg } } if msg.include?('<local-command-stdout>') || msg.include?('Caveat: The messages below were generated by the user while running local commands.')
      log 'User system message blocked: CASE SUCCESS'
      nil

      # User message - string content
    in { type: 'user', message: { content: String } }
      log 'User message: CASE SUCCESS'
      'user_message.txt'

      # Assistant - has text content
    in { type: 'assistant', message: { content: [{ text: String }] } }
      log 'Assistant message: CASE SUCCESS'
      'assistant_message.txt'

      # Assistant - Bash tool select
    in { type: 'assistant', message: { content: [{ name: 'Bash' }] } }
      log 'Assistant Bash tool: CASE SUCCESS'
      'assistant_tool_bash.txt'

      # Assistant - Skill used
    in { type: 'assistant', message: { content: [{ name: 'Skill' }] } }
      log 'Assistant Skill tool: CASE SUCCESS'
      'assistant_tool_skill.txt'

      # Assistant - Agent usage
    in { type: 'assistant', message: { content: [{ name: 'Task' }] } }
      log 'Assistant Task tool: CASE SUCCESS'
      'assistant_tool_task.txt'

      # Assistant - Agent usage
    in { type: 'assistant', message: { content: [{ type: 'thinking' }] } }
      log 'Assistant Thinking: CASE SUCCESS'
      'assistant_thinking.txt'

      # Assistant - Read, write, edit file
    in { type: 'assistant', message: { content: [{ name: name }] } } if %w[Write Read Edit].include?(name)
      log 'Assistant read / write tool: CASE SUCCESS'
      'assistant_tool_read&write.txt'

    else
      # Skip processing the line if case has not triggered
      log 'Line not valid: CASE SKIP'
      nil
    end

    return nil unless template

    result = render_template(template, line)
    log 'Template Render: SUCCESS'
    result
  end

  def render_template(template_name, data)
    template_path = File.join(TEMPLATES_DIR, template_name)
    template_content = File.read(template_path)
    context = deep_ostruct(data)
    ERB.new(template_content, trim_mode: '-').result(context.instance_eval { binding })
  end

  def rename_transcript(output_file)
    log 'Processing Conversation...'

    script_path = File.join(cwd, 'dev/run/process-conversation')

    unless File.exist?(script_path)
      log "Rename script not found: #{script_path}", level: :warn
      return
    end

    # Option A: Non-blocking - spawn and detach so session can exit immediately
    pid = spawn(script_path, output_file, out: File::NULL, err: File::NULL)
    Process.detach(pid)
    log "Conversation processing in background (PID: #{pid})"

    # # Option B: Blocking - wait for script to complete
    # result = system(script_path, output_file, out: File::NULL, err: File::NULL)
    # log "Rename script result: #{result}"
  rescue StandardError => e
    log "Failed to process conversation: #{e.message}", level: :warn
  end
end

# CLI testing
if __FILE__ == $0
  ClaudeHooks::CLI.test_runner(ExtractTranscript)
end
